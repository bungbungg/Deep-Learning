# -*- coding: utf-8 -*-
"""LSTM SYNTAX BERSIH.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gk9F2kiNo6kL_vWMg6QEVZ2g9ywBxAdl
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime as dt
from datetime import datetime
from keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint, TensorBoard
import math
# %matplotlib inline

# Importing Training Set
data = pd.read_csv('/content/data ', sep=';')
data

''' Pilih fitur (kolom) untuk dilibatkan dalam pelatihan intro dan prediksi'''

cols = list(data)[1:4]

''' Ekstrak data tanggal yang akan digunakan'''

datelist = list(data['tanggal'])
datelist = [dt.datetime.strptime(date, '%Y-%m-%d').date() for date in datelist]

print('Training set shape == {}'.format(data.shape))
print('All timestamps == {}'.format(len(datelist)))
print('Featured selected: {}'.format(cols))

data = data[cols].astype(str)
for i in cols:
    for j in range(0, len(data)):
        data[i][j] = data[i][j].replace(',', '')

data = data.astype(float)

''' Membuat dataset dengan beberapa fitur prediktor '''
dataset = data.values

print('Shape of training set == {}.'.format(dataset.shape))
dataset

"""## **NORMALISASI DATA**"""

''' Menormalisasikan data sebelum di training'''
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
dataset_scaled = scaler.fit_transform(dataset)
dataset_scaled

scaler_predict = MinMaxScaler()
prediksi = scaler_predict.fit_transform(dataset[:, 0:1])
prediksi

"""## **PEMBAGIAN DATA**"""

'''Membuat struktur data dengan 90 stempel waktu dan 1 output'''
X = []
y = []

n_predict = 60   #Jumlah hari yang paling ingin kita prediksi di masa depan'''
n_past = 90    #Jumlah hari terakhir yang ingin kita gunakan untuk memprediksi masa depan'''

'''Mempersiapkan data training'''
for i in range(n_past, len(dataset_scaled) - n_predict +1):
     X.append(dataset_scaled[i - n_past:i, 1:data.shape[0]- 1])
     y.append(dataset_scaled[i + n_predict - 1:i + n_predict, 0])
X, y = np.array(X), np.array(y)

X_train = X[0:round(0.8*X.shape[0])]
y_train = y[0:round(0.8*y.shape[0])]
X_test = X[math.ceil(-0.2*X.shape[0]):]
y_test = y[math.ceil(-0.2*y.shape[0]):]

print('X_train shape == {}.'.format(X_train.shape))
print('X_test shape == {}.'.format(X_test.shape))
print('y_train shape == {}.'.format(y_train.shape))
print('y_test shape == {}.'.format(y_test.shape))

"""##**MODELING LSTM**"""

# Import Libraries and packages from Keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout
from keras.optimizers import Adam

model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(n_past, data.shape[1]-1)))
model.add(LSTM(units=50, return_sequences=False))
model.add(Dropout(0.2))                          #----> add drop out
model.add(Dense(units=1, activation='sigmoid'))  # --->output layer

'''Compile Jaringan '''
model.compile(optimizer = Adam(learning_rate=0.001), loss='mean_squared_error', metrics=['mape', 'mse'])

# Commented out IPython magic to ensure Python compatibility.
# %%time
# tb = TensorBoard('logs')
# 
# history = model.fit(X_train, y_train, shuffle=True, epochs=1000 , validation_data=(X_test, y_test), verbose=1, batch_size=32)

''' Simpan model sesuai nama parameter'''

model.save('/content/co_25_1000_32.h5')

"""## **MODEL EVALUATION**

##**Evaluasi Training**
"""

mape = np.mean((history.history['mape']))
mape

mse = np.mean(history.history['mse'])
RMSE = math.sqrt(mse)
RMSE

import matplotlib.pyplot as plt
plt.plot(history.history['loss'])
plt.show()

"""## **Evaluasi Test**"""

import pandas as pd
import numpy as np
import tensorflow as tf
from tensorflow import keras
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout

from keras.models import load_model
model        = load_model('/content/co_25_1000_32.h5')

'''Memprediksi X test dengan model yang sudah dilatih'''

predict_test = model.predict(X_test)

'''Evaluasi MAPE model data testing'''

mape_test = np.mean(keras.metrics.mean_absolute_percentage_error(y_test, predict_test))
mape_test

'''Evaluasi RMSE model data testing'''

mse_test = np.mean(keras.metrics.mean_squared_error(y_test, predict_test))
RMSE_test = math.sqrt(mse_test)
RMSE_test

'''Grafik perbandingan prediksi data testing dengan data prediksi'''

plt.figure(figsize=(10, 6))
plt.plot(y_test, label='y_test')
plt.plot(predict_test, label='Predicted')
plt.legend()
plt.xlabel('Time Step')
plt.ylabel('Y Value')
plt.title('Peramalan Multivariate LSTM')


plt.show()

"""##**KEBUTUHAN MANIPULASI GRAFIK**"""

'''Untuk mengunduh data testing dan hasil prediksi data testing'''


y_testing = scaler_predict.inverse_transform(y_test)
y_pred_testing = scaler_predict.inverse_transform(predict_test)
y_testing  = pd.DataFrame(y_testing , columns=['y_test'])
y_pred_testing = pd.DataFrame(y_pred_testing, columns=['y_pred'])
testing = pd.concat([y_testing, y_pred_testing])
testing

'''Download'''
testing.to_excel("test.xlsx")

'''Upload Ulang'''
test = pd.read_excel('/content/test.xlsx')
test

'''Buat Grafik Baru'''
y_testing= test['y_test']
y_pred = test['y_pred']

plt.figure(figsize=(10, 6))
plt.plot(y_testing, label='y_test')
plt.plot(y_pred, label='Predicted')
plt.legend()
plt.xlabel('Time Step')
plt.ylabel('Y Value')
plt.title('Peramalan Multivariate LSTM')
plt.show()

"""# **PREDIKSI**
Bagian untuk konversi data array menjadi numerik agar bisa dibaca dan di visualisasikan
"""

''' Membuat daftar urutan hari yang akan di prediksi dengan datelist awal'''

datelist_predict= pd.date_range(datelist[-1], periods=n_predict, freq='1d').tolist()

'''Konversi Timestamp (pandas) to Datetime (untuk transformasi) --> future/masa depan'''

datelist_predict_ = []
for this_timestamp in datelist_predict:
    datelist_predict_.append(this_timestamp.date())


'''ubah <datetime.date> menjadi <Timestamp>'''

def datetime_to_timestamp(x):
    '''
        x : nilai tanggal waktu tertentu (datetime.date)
    '''
    return datetime.strptime(x.strftime('%Y%m%d'), '%Y%m%d')

''' Prediksi PM 10 60 hari yang akan datang'''
predict_future = model.predict(X_train[-n_predict:])

'''Mengembalikan nilai prediksi ke nilai pengukuran awal agar dapat dibaca'''
pred_future = scaler_predict.inverse_transform(predict_future)


'''Menampilkan tabel hasil prediksi'''
predictions_future = pd.DataFrame(pred_future, columns=['pm10']).set_index(pd.Series(datelist_predict))
predictions_future.index = predictions_future.index.to_series().apply(datetime_to_timestamp)
predictions_future

'''Mengunduh data hasil prediksi masa depan'''
predictions_future.to_excel("predictions_future.xlsx")

y_actual = scaler_predict.inverse_transform(prediksi)
y_actual = pd.DataFrame(y_actual, columns=['pm10']).set_index(pd.Series(datelist))
y_actual.index = y_actual .index.to_series().apply(datetime_to_timestamp)
y_actual

from pylab import rcParams
rcParams['figure.figsize'] = 14, 5

'''Menentukan start periode tanggal yang akan ditampilkan pada visualisasi'''
start_date = '2021-01-01'

plt.plot(predictions_future.index, predictions_future['pm10'], color='blue', label='Prediksi PM 10')
plt.plot(y_actual.loc[start_date:].index, y_actual.loc[start_date:], color='red', label='data aktual')
plt.axvline(x = min(predictions_future.index), color='green', linewidth=2, linestyle='--')
plt.grid(which='major', color='#cccccc', alpha=0.1)

plt.legend(shadow=True)
plt.title('Prediksi PM 10', family='Arial', fontsize=12)
plt.xlabel('Timeline', family='Arial', fontsize=10)
plt.ylabel('PM 10', family='Arial', fontsize=10)
plt.xticks(rotation=45, fontsize=8)
plt.show()

"""# **Print** **BOBOT**"""

from keras.models import load_model
model= load_model('/content/co_25_1000_32.h5')

units = int(int(model.layers[1].trainable_weights[0].shape[1])/4)
print("No units: ", units)

W = model.layers[0].get_weights()[0]
U = model.layers[0].get_weights()[1]
b = model.layers[0].get_weights()[2]
f = model.layers[0].get_weights()[0]

W = model.layers[0].get_weights()[0]
U = model.layers[0].get_weights()[1]
b = model.layers[0].get_weights()[2]
W_i = W[:, :units]
W_f = W[:, units: units * 2]
W_c = W[:, units * 2: units * 3]
W_o = W[:, units * 3:]
U_i = U[:, :units]
U_f = U[:, units: units * 2]
U_c = U[:, units * 2: units * 3]
U_o = U[:, units * 3:]

b_i = b[:units]
b_f = b[units: units * 2]
b_c = b[units * 2: units * 3]
b_o = b[units * 3:]

W_f



W_i

b_f