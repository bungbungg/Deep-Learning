# -*- coding: utf-8 -*-
"""SEGMENTASI MANUAL FIX.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CN4Y3JMM6qXV6naA08Y12b_KK4TviOQU
"""

# import library

import cv2
import matplotlib.pyplot as plt
import numpy as np

# load image
image = cv2.imread('/content/segmen.jpeg')

# convert image from BGR to RGB
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# show the image
plt.imshow(image)

image

iamge = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.imshow(image)
plt.show()

from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib import colors

pixel_colors = image.reshape((np.shape(image)[0]*np.shape(image)[1], 3))
norm = colors.Normalize(vmin=-1.,vmax=1.)
norm.autoscale(pixel_colors)
pixel_colors = norm(pixel_colors).tolist()

hsv_image = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)

h, s, v = cv2.split(hsv_image)
fig = plt.figure()
axis = fig.add_subplot(1, 1, 1, projection="3d")

axis.scatter(h.flatten(), s.flatten(), v.flatten(), facecolors=pixel_colors, marker=".")
axis.set_xlabel("Hue")
axis.set_ylabel("Saturation")
axis.set_zlabel("Value")
plt.show()

# Reshaping the image into a 2D array of pixels and 3 color values (RGB)

img1D = image.reshape((-1,3))

print(img1D.dtype, img1D.shape)

# Convert to float type

Z = np.float32(img1D)
print(Z.dtype, Z.shape)

# define criteria, number of clusters(K) and apply kmeans() from

#setiap kali 10 iterasi algoritme dijalankan, atau akurasi epsilon = 1.0 tercapai, hentikan algoritma dan kembalikan jawabannya.
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)

#Jumlah K ditentukan berdasarkan warna dominasi pada tensor
K = 2

ret,label,center=cv2.kmeans(Z,K,None,criteria,10,cv2.KMEANS_RANDOM_CENTERS)
print(label)

print(center)



# back convert data into integer 8-bit values

center = np.uint8(center)
center

# back to cluster

segmented_data = center[label.flatten()]
segmented_data

# reshape data into the original image dimensions

segmented_image = segmented_data.reshape((image.shape))
segmented_image

# visualize the segmented image

plt.imshow(segmented_image)

resize_img = cv2.resize(image,(5,5))

# Reshaping the image into a 2D array of pixels and 3 color values (RGB)

img1D = resize_img.reshape((-1,3))
print(img1D.dtype, img1D.shape)

# Convert to float type

Z = np.float32(img1D)
print(Z.dtype, Z.shape)

resize_img

# define criteria, number of clusters(K) and apply kmeans() from
# https://docs.opencv.org/4.x/d1/d5c/tutorial_py_kmeans_opencv.html

#setiap kali 10 iterasi algoritme dijalankan, atau akurasi epsilon = 1.0 tercapai, hentikan algoritma dan kembalikan jawabannya.
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)

#Jumlah K ditentukan berdasarkan warna dominasi pada tensor
K = 2

ret,label,center=cv2.kmeans(Z,K,None,criteria,10,cv2.KMEANS_RANDOM_CENTERS)
print(label)

print(center)

# back to cluster

segmented_data = center[label.flatten()]
segmented_data